---
layout: post
author: Berry Qiu
title: 
subtitle: 
cover: 
color: '' # 默认根据字数生成相应颜色
tags: 
    - 计算机网络
    - 学习笔记

tips: [TCP, UDP, 拥塞控制与流量控制, 三次握手, 四次握手]
---

# 传输层

## 传输层的功能

- 传输层为**应用进程之间**提供**端到端的**逻辑通信（网络层是主机之间的逻辑通信）
- 传输层还要对收到的报文进行差错监测。
- 传输层提供面向连接(TCP)和无连接(UDP)的服务。

## 传输层的两个协议

- TCP：Transmission Control Protocol，传输控制协议。需要将要传输的文件分段，传输过程中会建立会话，属于可靠传输，需要流量控制。
- UDP：User Datagram Protocol，用户数据报协议。一个数据包就能完成数据通信，不分段，不需要建立会话，不需要流量控制，不可靠。
  - 屏幕广播、多播
  - QQ文字聊天

```powershell
netstat -n	# 查看会话
netstat -nb # 查看建立会话的进程，需要管理员权限
```

### 传输层协议和应用层协议之间的关系

|     应用层协议       |     传出层协议       |  端口    |
| :--------: | :--------: | :--: |
| http | TCP | 80 |
|    https    |    TCP    | 443  |
| RDP（远程桌面协议） | TCP | 3389 |
| ftp | TCP | 21 |
| 访问共享文件夹 | TCP | 445 |
| SMTP（简单邮件传输协议） | TCP | 25 |
| telnet | TCP | 23 |
| SQL | TCP | 1433 |
| DNS | UDP/TCP | 53 |

### 服务于应用层协议之间的关系

- 客户端通过IP地址定位服务器，通过端口选择服务
- 服务器侦听端口侦听客户端发来的服务请求
- 在服务器只开放必要的端口能够提升服务器安全

### TCP的端口

端口用一个16位端口号进行标志。（0~65535）

端口号只具有**本地**意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。

#### 三类端口

- 熟知端口：0~1023。
- 登记端口：1024~49151。提供给新增应用。
- 客户端口：49152~65535。

## UDP

### UDP的主要特点

- UDP是**无连接的**，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
- UDP使用**尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
- UDP是**面向报文**的。不拆分应用层下来的报文，故数据太大IP层需要分片。
- UDP**没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低，很适合多媒体通信的要求。
- UDP**支持一对一、一对多、多对一和多对多**的交互通信。
- UDP的**首部开销小**，只有8个字节。

### UDP的首部格式

![UDP首部](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200218225443.png)

1. 源端口：源端口号。在需要对方回信时选用，不需要时可为0.
2. 目的端口
3. 长度：最小值是8（仅有首部）
4. 检验和：需要把伪首部和数据算在里面，求和反码得出结果。

## TCP

### TCP的主要特点

- TCP是**面向连接的传输层协议**。也就是说，应用程序在使用TCP之前，必须先建立TCP连接，传输完成后，必须释放TCP连接。（三次握手、四次挥手）
- 每一条TCP连接只能有两个**端点**(endpoint)，每一条TCP连接只能是**点对点**的（一对一）。
-  TCP提供**可靠交付**的服务。
- TCP提供**全双工通信**。
- **面向字节流**。

### TCP的连接

- TCP把**连接**作为**最基本的抽象**。
- 每一条TCP连接有两个**端点**。
- TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传出层的协议端口。TCP连接的端点叫做**套接字(socket)**或插口。
  - 套接字socket = (IP地址:端口号)
- 同一个IP地址可以有多个不同的TCP连接

## 可靠传输的工作原理

### 停止等待协议

- 发送方发完一个数据后等待，若收不到接收方的确认消息就重发，收到了就发送下一个数据。
- 使用确认和重传机制，就可以在**不可靠的传输网络上实现可靠的通信**。

#### 1. 无差错情况

![无差错](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200220154532.png)

#### 2. 出现差错

![出现差错](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200220154628.png)

#### 3. 确认丢失和确认迟到

![确认丢失和确认迟到](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200220155527.png)

上述这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat reQuest)。表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。

#### 4. 信道利用率

停止等待协议的优点是**简单**，缺点是**信道利用率太低**。

![信道利用率](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200220155423.png)

- $T_D$ ： A发送分组需要的时间
- $T_A$ ： B发送确认分组需要的时间。
- $RTT$ ：往返时间。

$$
U = \frac {T_D} {T_D + RTT + T_A}
$$

为了提高传输效率，发送方不不使用低效率的停止等待协议，而是采用**流水线传输**。

![流水线传输](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200220160236.png)

### 连续ARQ协议

- 发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。
- 接收方一般采用**累计确认**的方式。即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，**对按序到达的最后一个分组发送确认**，表示到这个分组为止的所有分组都已经正确收到了。

## TCP报文段的首部格式

![TCP报文段的首部格式](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200220161338.png)

1. 目标端口和源端口：各占2Byte。

2. 序号：4Byte。[$ 0\sim 2^{32}-1$]。表示数据部分的第一个字节是整个文件的第n个字节。  

3. 确认号：4Byte。**期望收到对方下一个报文段的第一个数据字节的序号**。下次该发第n个字节了。

   ```
   若确认号 = N， 则表明：到序号N-1为止的所有数据都已正确收到。
   ```

4. 数据偏移量：4Bit。TCP报文段数据起始处距离TCP报文段的起始处有多远。

5. 保留：6Bit，置零。

6. 紧急URG（URGent）：`URG = 1`时为紧急数据，不用排队。

7. 确认ACK（ACKnowledge）：`ACK = 1`时确认号才有效。

8. 推送PSH（PuSH）：接收方收到`PSH = 1`的报文段时无需等待缓存直接向上交付。

9. 复位RST（ReSeT）：`RST = 1`时表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。也用来拒绝一个非法的报文段或拒绝打开一个连接。

   - 浏览器上与刷新对应的X

10. 同步SYN（SYNchronization）：`SYN = 1`表示这是一个**连接请求**或**连接接受**报文。

    - `SYN = 1, ACK = 0`表示连接请求
    - `SYN = 1, ACK = 1`表示同意建立连接。

11. 终止FIN（FINis）：用来释放一个连接。`FIN = 1`时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。

12. 窗口：2Bytes。[0~65535]。窗口值**告诉对方**：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。**窗口值作为接收方让发送方设置其发送窗口的依据**

13. 检验和：2Bytes。和UDP一样，在计算检验和时需要加上12字节的伪首部。

14. 紧急指针：2Bytes。仅在`URG = 1`时有意义。指出紧急数据的末尾在报文段中的位置。所有紧急数据处理完后，TCP就告诉应用程序恢复到正常操作。

15. 选项：长度可变，最长40字节。

    1. 最大报文段长度MSS(Maximum Segment Size)：每一个TCP报文段中数据字段的最大长度。`MSS = TCP报文段长度 - TCP首部长度` 

## TCP可靠传输的实现

### 以字节为单位的滑动窗口

1. 发送接收数据未丢失

![无丢数据传送](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200220213718.gif)

2. 分组发生丢失

![累积确认](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200220221103.gif)



### 超时重传时间的选择

RTT的加权平均往返时间RTTs：
$$
新的RTTs = (1-\alpha) \times (旧的RTTs) +\alpha\times(新的RTT样本)
$$
RFC2988推荐的α值为1/8。

显然，超时计时器设置的**超时重传时间RTO**(RetransmissionTime-Out)应略大于RTTs。

RFC2988建议使用下式计算RTO：
$$
RTO = RTT_S + 4\times RTT_D
$$

- $RTT_D$为RTT的偏差加权平均值，第一次测量时取RTT的一半。

- $新的RTT_D = (1 - \beta) \times (旧的RTT_D) + \beta \times |RTT_S-新的RTT样本|$
  
  - $\beta$推荐值为1/4.	

![等待重传](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200220215732.gif)

### 选择确认SACK

SACK用来标记缺失的部分（前后必须有已排好的分组，也就是说必须要中间缺失）。

指明一个边界需要4字节（序号有4字节），而一个字节块有两个边界、首部选项的长度最多40字节，故最多只能指明**4个字节块的边界信息（8个边界）**，即32字节。另外还有额外两个字节：一个指明是SACK选项，一个指明这个选项要占用多少字节。

## TCP的流量控制

### 利用滑动窗口实现流量控制

所谓**流量控制(flow control)就是让发送方的发送速率不要太快，要让接收方来得及接收**。

![利用滑动窗口实现流量控制](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200221000205.png)

如图所示，接收方不断减小窗口值`rwnd`，使发送方发送数据减少，当`rwnd = 0`时，就不允许发送方发送数据了。

- TCP为每个连接设有一个**持续计时器**（persistence timer）。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。定时发送一个零窗口探测报文段（仅携带1字节数据），对方就在确认这个探测报文段时给出现在的窗口值。

## TCP的拥塞控制

在某段时间内，若对网络中**某一资源的需求超过了该资源所能提供的可用部分**，网络的性能就要变坏，这种情况就叫**拥塞**（congestion）。
$$
\sum 对资源的需求 > 可用资源
$$

### 拥塞控制与流量控制

**拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。**

拥塞控制的前提：网络能够承受现有的网络负荷。

拥塞控制是一个**全局性**的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。

**流量控制往往指点对点的控制，是端对端的问题**（在给定的发送端和接收端之间的点对点通信量的控制），它所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

![拥塞控制](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200221175136.png)

### 拥塞控制方法

因特网建议标准RFC 2581定义了进行拥塞控制的四种算法：**慢开始(slow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)和快恢复(fast recovery)**。

#### 1. 慢开始和拥塞避免

**发送方**维持一个叫**拥塞窗口cwnd**(congestion window)的状态变量。

慢开始算法：由小到大逐渐增大拥塞窗口的数值（一般cwnd初始设为最大报文段MSS）。发送方每收到一个确认，就使拥塞窗口增加1，即每经过一个**传输轮次**，拥塞窗口的数值就增大一倍。

![慢开始](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200221195023.png)

为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个**慢开始门限**(ssthresh)状态变量。

- 当`cwnd < ssthresh`时，使用**慢开始算法**。
- 当`cwnd > ssthresh`时，改用**拥塞避免算法**。
- 当`cwnd = ssthresh`时，两算法都可。

拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。

![慢开始算法和拥塞避免算法](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200221205047.png)

- 乘法减小：`ssthresh`为出现拥塞时`cwnd`的一半。
- 加法增大：执行拥塞避免算法后，`cwnd`缓慢增大，以防止网络过早出现拥塞。
- AIMD算法：加法增大乘法减小算法

#### 2. 快重传和快恢复

快重传算法：

- 快重传算法首先要求接收方每收到一个**失序的报文段**后就立即发出重复确认（为的是使发送方**及早知道**有报文段没有到达对方）而不要等待自己发送数据时才进行稍待确认。
- 快重传算法规定，发送方只要**一连收到三个重复确认**就应当重传对方尚未收到的报文段，而不必继续等待重传计时器到期。

![快重传](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200221212850.png)

- 如图，接收方收到M4时不能确认M4（失序的报文段），按照快重传算法规定，应该发送对M2的**重复确认**。

快恢复算法：

1. 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，将`ssthresh`减半。这是为了**预防**网络发生拥塞。
2. 由于发送方现在认为网络**很可能没有发生拥塞**，故不执行慢开始算法，而是把`cwnd`值设置为慢开始门限`ssthresh`减半后的数值，然后开始执行拥塞避免算法（“加法增大”）。

![快重传和快恢复](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200221212341.png)

### 发送方发送窗口的上限值

考虑到流量控制（接收方的接收窗口`rwnd`）和拥塞控制（发送方的拥塞窗口`cwnd`），发送方的发送窗口应当取二者中较小的一方，即：
$$
发送方窗口的上限值 = \min (rwnd, cwnd)
$$
所以，`rwnd`和`cwnd`中较小的一个控制发送方发送数据的速率。

### 随机早期检测RED

属于路由器的措施，对网络拥塞控制也有关系。

## TCP的传输连接管理

传输连接有三个阶段：**建立连接、数据传送**和**连接释放**。

### TCP的连接建立（三次握手）

![三次握手](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200222164040.png)

- B的TCP服务器进程先创建**传输控制块TCB**，准备接受客户进程的连接请求。然后服务器进程就处于`LISTEN`（收听）状态，等待客户的连接请求。
- A的TCP客户进程也首先创建传输控制块TCB，然后向B发出连接请求报文段。这时，TCP客户进程进入`SYN-SENT`（同步已发送）状态。
  - TCP规定`SYN`报文段不能携带数据，但要**消耗一个序号**。这也是为什么B的确认号是`ack = x+1`。
- B收到请求，若同意建立连接，就向A发送确认。这时TCP服务器进程进入`SYN-RCVD`（同步收到）状态。
- A的TCP客户进程收到B的确认后，还要向B给出确认。这时，TCP连接已经建立，A进入`ESTABLISHED`状态。
  - TCP规定，`ACK`报文段可以携带数据。但**如果不携带数据则不消耗序号**，这样的话下一个数据报文段的序号仍是`seq = x+1`。
- B收到A的确认后，也进入`ESTABLISHED`状态。

总结：

1. `SYN`，A->B
2. `SYN+ACK`，B->A
3. `ACK`，A->B

> Q：为什么A还要发送一次确认？
>
> A：当A发出了一个连接请求，在路上堵住了（**失效的连接请求报文段**），A只好再发一个连接请求，这次可以和B正常建立连接。当AB连接释放后，B收到了在路上堵住的第一个连接请求，这时B向A发出确认，同意建立连接。如果只有两次握手，那么此时B就已经建立了新的连接。但是A并没有发出建立连接的请求，所以不会理睬B，也不会向B发送数据。B却一直苦苦等待，等不到头，许多资源就这么浪费了。
>
> 如果采用三次握手，因为A不会向B发送确认，所以B就不会建立连接。

### TCP的连接释放（四次握手/挥手）

![四次挥手](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200222164148.png)

- A把向B发送的**连接释放报文段**首部`FIN = 1`，进入`FIN-WAIT1`（终止等待1）状态，等待B的确认。（注意到这里没有指定`ACK`）
  - `seq = u`，是A前面已传送过的数据的最后一个字节的序号加1。
  - TCP规定，`FIN`报文段即使不携带数据，也要消耗一个序号。
- B收到连接释放报文段后即发出确认，进入`CLOSE-WAIT`(关闭等待)状态。
  - `seq = v`，是B前面已传送过的数据的最后一个字节的序号加1。
  - `ack = u+1`
- B的TCP服务器进程这时应通知高层应用进程，`A->B`的连接就释放了，这时的TCP连接处于**半关闭(half-close)**状态，即**A已经没有数据要发送了，但B若发送数据，A仍要接收**。
- A收到来自B的确认后，就进入`FIN-WAIT2`（终止等待2）状态，等待B发出的连接释放报文段。
- 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这是B发出的连接释放报文段`FIN = 1`，`ACK = 1`。这是B进入`LAST-ACK`（最后确认）状态，等待A的确认。
  - `seq = w`，考虑到半关闭状态B可能又返送了一些数据。
  - `ack = u+1`，B要重复上次已发送的确认号。（所以这里`ACK`为1）
- A收到B的连接释放报文段后，必须对此发出确认，在确认报文段中把`ACK`置1，进入`TIME-WAIT`（时间等待）状态。
  - `seq = u+1`，`ack = w+1`。
- 在`TIME-WAIT`的A还没释放TCP连接，必须经过**时间等待计时器（TIME-WAIT timer)**设置的时间2MSL后，A才进入到`CLOSED`状态。
  - MSL：最长报文段寿命，Maximum Segment Lifetime。RFC 793建议为2分钟。
  - 要经过**4分钟**才能进入`CLOSED`状态，才能开始建立下一个连接。
  - 当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。
- B收到A发出的确认，就进入`CLOSED`状态。
  - B结束TCP连接的时间比A早一些
  - B在撤销相应的传输控制块TCP后，就结束了这次的TCP连接。

总结：

1. `FIN`，A->B
2. `ACK`，B->A
3. `FIN+ACK`，B->A
4. `ACK`，A->B

>Q：为什A在`TIME-WAIT`状态必须等待2MSL时间呢？
>
>A：有两个理由：
>
>1. 为了保证A发送的最后一个`ACK`报文段能够到达B。因为这个`ACK`报文段很有可能丢失，使处在`LAST-ACK`状态的B收不到对已发送的`FIN+ACK`报文段的确认。这时B就会**超时重传**这个报文段，而A就能在2MSL时间内收到这个重传的`FIN+ACK`报文段。接着A重传一次确认，**重新启动2MSL计时器。**如果A不等待一段时间，而是在发送完`ACK`报文段后立即释放连接，那么久无法收到B重传的`FIN+ACK`报文段，这样B就无法按照正常步骤进入`CLOSED`状态。
>2. 防止“**已失效的连接请求报文段**”出现在本连接中。A在发送完最后一个`ACK`报文段后，在经过2MSL时间，就能使本连接持续的时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

TCP还设有一个**保活计时器（keepalive timer）**,防止客户端主机突然故障而服务器端白白等下去的情况。一般是两小时，两小时无响应后就发送一个探测报文段，之后每隔75分钟发送一个探测报文段，连续发送10个仍无响应，服务器就认为客户端故障，关闭这个连接。

### TCP的有线状态机

![TCP的有线状态机](https://gitee.com/qiutongxue/blog-images/raw/master/img/20200222171327.png)

- 方框：TCP可能具有的状态
- 箭头：可能发生的状态变迁
  - 粗实线：对客户进程的正常变迁
  - 粗虚线：对服务器进程的正常变迁
  - 细线：异常变迁
- 箭头旁的字：引起这种变迁的原因，或发生状态变迁后又出现什么动作
